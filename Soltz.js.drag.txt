//@ts-check
'use strict';
/* jshint esversion:6 */

const Constants = {
  GAME_NAME: 'Oddstream Solitaire',
  GAME_VERSION: '0.6.2.0',
  SVG_NAMESPACE: 'http://www.w3.org/2000/svg',
  LOCALSTORAGE_SETTINGS: 'Oddstream Soltz Settings',
  LOCALSTORAGE_GAMES: 'Oddstream Soltz Games',

  MOBILE:     /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
  CHROME:     navigator.userAgent.indexOf('Chrome/') !== -1,   // also Brave, Opera
  EDGE:       navigator.userAgent.indexOf('Edge/') !== -1,
  FIREFOX:    navigator.userAgent.indexOf('Firefox/') !== -1,

  GRID_SIZE: 4,
  GRID_GAP: 200,
  CARD_SIZE: 100, // square cards, width == height
  CARD_GAP: 4,
  CARD_RADIUS: 5,
}

const rectColors = new Map([
  [2, '#eee4da'],
  [4, '#ece0c8'],
  [8, '#f2b179'],
  [16, '#f59563'],
  [32, '#f57c5f'],
  [64, '#f65e3b'],
  [128, '#edcf72'],
  [256, '#edcc61'],
  [512, '#edc850'],
  [1024, '#edc53f'],
  [2048, '#edc22e'],
]);

const valueColors = new Map([
  [2, '#73695F'],
  [4, '#73695F'],
  [8, '#73695F'],
  [16, '#FDF3F1'],
  [32, '#FDF3F1'],
  [64, '#FDF3F1'],
  [128, '#FDF3F1'],
  [256, '#FDF3F1'],
  [512, '#FDF3F1'],
  [1024, '#FDF3F1'],
  [2048, '#FDF3F1'],
]);

const Util = {
  /**
   * @param {SVGPoint} pt1 
   * @param {SVGPoint} pt2 
   * @returns {number}
   */
  getDistance: function(pt1, pt2) {
    return Math.hypot(pt2.x - pt1.x, pt2.y - pt1.y);     // see 30 seconds of code
  },

  /**
   * @param {(number|SVGPoint)} x
   * @param {number=} y
   * @returns {SVGPoint}
  */
  newPoint: function(x, y=undefined) {
  // https://developer.mozilla.org/en-US/docs/Web/API/SVGPoint
    const pt = baize.ele.createSVGPoint();
    if ( typeof x === 'object' ) {
      pt.x = x.x;
      pt.y = x.y;
    } else if ( typeof x === 'number' && typeof y === 'number' ) {
      pt.x = x;
      pt.y = y;
    } else {
      throw new TypeError();
    }
    return pt;
  },

  // /**
  //  * @param {SVGPoint} ptDst 
  //  * @param {SVGPoint} ptSrc 
  //  */
  // copyPoint: function(ptDst, ptSrc) {
  //   ptDst.x = ptSrc.x;
  //   ptDst.y = ptSrc.y;
  // },

  // /**
  //  * @param {SVGPoint} pt1
  //  * @param {SVGPoint} pt2
  //  * @returns {boolean}
  //  */
  // samePoint: function(pt1, pt2) {
  //   return ( (pt1.x === pt2.x) && (pt1.y === pt2.y) );
  // },

  // /**
  //  * @param {SVGPoint} pt1
  //  * @param {SVGPoint} pt2
  //  * @param {number=} slack
  //  * @returns {boolean}
  //  */
  // nearlySamePoint: function(pt1, pt2, slack=Constants.CARD_SIZE / 4) {
  //   const xMin = pt1.x - slack;
  //   const xMax = pt1.x + slack;
  //   const yMin = pt1.y - slack;
  //   const yMax = pt1.y + slack;
  //   return ( pt2.x > xMin && pt2.x < xMax && pt2.y > yMin && pt2.y < yMax );
  // },

  /**
   * @param {number} x 
   * @param {number} y 
   * @returns {SVGPoint}
   */
  DOM2SVG: function(x, y) {
    // https://www.sitepoint.com/how-to-translate-from-dom-to-svg-coordinates-and-back-again/
    const pt = Util.newPoint(x,y);
    // https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement
    /** @type {SVGGraphicsElement} */ const sge = baize.ele;
    pt.matrixTransform(sge.getScreenCTM().inverse());
    pt.x = Math.round(pt.x);
    pt.y = Math.round(pt.y);
    return pt;
  },

  /**
   * @param {Event} event 
   * @returns {boolean}
   */
  absorbEvent: function(event) {
    var e = event || window.event;
    e.preventDefault && e.preventDefault();
    e.stopPropagation && e.stopPropagation();
    e.cancelBubble = true;
    e.returnValue = false;
    return false;
  },

  /**
   * @param {Element} ele 
   * @param {Object} attribs 
   */
  setAttributesNS(ele, attribs) {
    for ( let a in attribs ) {
      ele.setAttributeNS(null, a, attribs[a]);
    }
  }

}

class AssociationTable {
  // https://en.wikipedia.org/wiki/Associative_entity
  constructor() {
    this.mapPlaceCard = new Map();
    this.mapCardPlace = new Map();
  }

  /**
   * @param {Place} place 
   * @param {Card} card 
   */
  putCard(place, card) {
    this.mapPlaceCard.set(place, card);
    this.mapCardPlace.set(card, place);
  }

  /**
   * @param {Place} place 
   */
  getCard(place) {
    return this.mapPlaceCard.get(place);
  }

  /**
   * @param {Card} card 
   */
  getPlace(card) {
    return this.mapCardPlace.get(card);
  }

  /**
   * @param {Place} fromPlace 
   * @param {Place} toPlace 
   */
  moveCard(fromPlace, toPlace) {
    const card = this.mapPlaceCard.get(fromPlace);

    this.mapPlaceCard.delete(fromPlace);
    this.mapCardPlace.delete(card);
    
    this.mapPlaceCard.set(toPlace, card);
    this.mapCardPlace.set(card, toPlace);
  }

  /**
   * @param {Place} place1 
   * @param {Place} place2 
   */
  swapCards(place1, place2) {
    const card1 = this.mapPlaceCard.get(place1);
    const card2 = this.mapPlaceCard.get(place2);

    this.mapPlaceCard.delete(place1);
    this.mapCardPlace.delete(card1);

    this.mapPlaceCard.delete(place2);
    this.mapCardPlace.delete(card2);

    this.mapPlaceCard.set(place1, card2);
    this.mapCardPlace.set(card2, place1);

    this.mapPlaceCard.set(place2, card1);
    this.mapCardPlace.set(card1, place2);
  }

  /**
   * @param {Card} card 
   */
  deleteCard(card) {
    const place = this.mapCardPlace.get(card);

    this.mapPlaceCard.delete(place);
    this.mapCardPlace.delete(card);
  }
}

const asstab = new AssociationTable();

class Baize {
  constructor() {
    this.ele = document.getElementById('baize');
  }

  /**
   * @private
   * @param {number} b positive or negative border width
   */
  adjustBorder_(b) {
    const nodes = this.ele.querySelectorAll('.Place');
    for ( let n=0; n<nodes.length; n++ ) {
      let r = nodes[n];
      if ( r.hasAttribute('x') ) {
        let x = Number.parseInt(r.getAttribute('x'), 10) || 0;
        r.setAttributeNS(null, 'x', String(x + b));
      }
    }
    grid.places.forEach( c => {
      c.pt.x += b;
    });
    const sc = this.ele.querySelector('#score');
    if ( sc.hasAttribute('x') ) {
      let x = Number.parseInt(sc.getAttribute('x'), 10) || 0;
      sc.setAttributeNS(null, 'x', String(x + b));
    }
  }

  /**
   */
  setBox() {
    // console.warn(window.screen.orientation, window.screen.width, window.screen.height);
    this.gutsWidth = Constants.GRID_GAP + (Constants.GRID_SIZE * (Constants.CARD_SIZE + Constants.CARD_GAP)) + Constants.GRID_GAP;
    this.width = this.gutsWidth;
    this.height = Math.max(1200,window.screen.height);

    if ( window.screen.width > window.screen.height ) {
      // landscape, add a border if guts are narrow
      const thresholdWidth = 1000;
      if ( this.gutsWidth < thresholdWidth ) {
        this.borderWidth = (thresholdWidth - this.gutsWidth) / 2;
        this.adjustBorder_(this.borderWidth);
        this.width = thresholdWidth;
      }
    }
    // set viewport (visible area of SVG)
    Util.setAttributesNS(this.ele, {
      width: String(this.width),
      height: String(this.height),
      viewBox: `0 0 ${this.width} ${this.height}`,
      preserveAspectRatio: 'xMinYMin slice'
    });
  }

  /**
   * @param {Card} c
   */
  addCard(c) {
    this.ele.appendChild(c.g);
  }

  /**
   * @param {Card} c
   */
  deleteCard(c) {
    this.ele.removeChild(c.g);
  }

  /**
   * Move card to end of baize so it appears on top of other cards
   * Should be using SVG z-index to do this, but it's not implemented
   * @param {Card} c
   */
  elevateCard(c) {
    if ( c.g !== this.ele.lastChild )
      this.ele.appendChild(c.g);
  }
}

class Score {
  constructor() {
    this.score = 0;
    this.text = document.createElementNS(Constants.SVG_NAMESPACE, 'text');
    this.text.classList.add('score');
    Util.setAttributesNS(this.text, {
      'id': 'score',
      'x': Constants.GRID_GAP + ((Constants.GRID_SIZE * (Constants.CARD_SIZE + Constants.CARD_GAP))/2),
      'y': Constants.GRID_GAP / 2,
      'text-anchor': 'middle',
      // https://www.w3.org/TR/SVG11/text.html#DominantBaselineProperty
      'dominant-baseline': 'central',
    });
    this.updateText_();
    baize.ele.appendChild(this.text);
  }

  updateText_() {
    this.text.innerHTML = String(this.score);
  }

  /**
   * 
   * @param {number} amt 
   */
  inc(amt) {
    this.score += amt;
    this.updateText_();
  }
}

// https://stackoverflow.com/questions/20368071/touch-through-an-element-in-a-browser-like-pointer-events-none/20387287#20387287
function dummyTouchStartHandler(e) {e.preventDefault();}

class Card {
  /**
   * g>rect>text
   * @param {!number} value 
   */
  constructor(value) {
    this.value = value;
    this.g = /** @type {SVGGElement} */(document.createElementNS(Constants.SVG_NAMESPACE, 'g'));
    this.createRect_();
    this.createText_();

    /** @type {number[]} */this.animationIds = [];

    this.downHandler = this.onpointerdown.bind(this);
    this.moveHandler = this.onpointermove.bind(this);
    this.upHandler = this.onpointerup.bind(this);
    this.cancelHandler = this.onpointercancel.bind(this);
    this.addListeners_();
  }

  destroy() {
    this.removeListeners_();
    baize.deleteCard(this);
  }

  /**
   * @private
   * @returns Element
   */
  createRect_() {
    this.rect = document.createElementNS(Constants.SVG_NAMESPACE, 'rect');
    this.rect.classList.add('spielkarte', 'new');
    Util.setAttributesNS(this.rect, {
      width: String(Constants.CARD_SIZE),
      height: String(Constants.CARD_SIZE),
      rx: String(Constants.CARD_RADIUS),
      ry: String(Constants.CARD_RADIUS),
    });
    this.updateRect_();
    this.g.appendChild(this.rect);
  }

  updateRect_() {
    Util.setAttributesNS(this.rect, {
      fill: rectColors.get(this.value)
    });
  }

  /**
   * @private
   */
  createText_() {
    console.assert(!!this.value);
    this.text = document.createElementNS(Constants.SVG_NAMESPACE, 'text');
    this.text.classList.add('spielkartevalue', 'new');
    Util.setAttributesNS(this.text, {
      'x': String(Constants.CARD_SIZE/2), // '50%' didn't work
      'y': String(Constants.CARD_SIZE/2), // '50%' didn't work
      'text-anchor': 'middle',
      // https://www.w3.org/TR/SVG11/text.html#DominantBaselineProperty
      'dominant-baseline': 'central',
    });
    this.updateText_();
    this.g.appendChild(this.text);
  }

  /**
   * private
   */
  updateText_() {
    let fontSize = undefined;
    const txtValue = String(this.value);
    switch ( txtValue.length ) {
      case 1: fontSize = '56'; break;
      case 2: fontSize = '48'; break;
      case 3: fontSize = '48'; break;
      case 4: fontSize = '36'; break;
    }
    Util.setAttributesNS(this.text, {
      'font-size': fontSize,
      'fill': valueColors.get(this.value)
    });
    this.text.innerHTML = txtValue;
  }

  /**
   * Use SVG transform to position this card on the baize
   * @param {number} x
   * @param {number} y
   */
  positionXY(x, y) {
    this.g.setAttributeNS(null, 'transform', `translate(${x} ${y})`);
  }

  /**
   * Use SVG transform to position this card on the baize
   */
  position0() {
    const place = asstab.getPlace(this);
    console.assert(!!place);
    this.positionXY(place.pt.x, place.pt.y);
  }

  /**
   * @param {number} x 
   * @returns {!number}
   * @private
   */
  smootherstep_(x) {
    return ((x) * (x) * (x) * ((x) * ((x) * 6 - 15) + 10));
  }

  /**
   * animate this card to it's place
   * @param {SVGPoint} ptFrom
   */
  animate(ptFrom) {
    const step_ = (timestamp) => {
      const v = this.smootherstep_(i / N);
      const x = Math.round((ptFrom.x * v) + (ptTo.x * (1 - v)));
      const y = Math.round((ptFrom.y * v) + (ptTo.y * (1 - v)));
      this.positionXY(x, y);

      i -= N/10;
      if ( i > 0 ) {
        this.animationIds.push(window.requestAnimationFrame(step_));
      } else {
        this.position0();
        this.animationIds.length = 0;
      }
    };

    const place = asstab.getPlace(this);
    const ptTo = Util.newPoint(place.pt);
    const N = Util.getDistance(ptFrom, ptTo);
    let i = N;
    if ( N ) {
      window.requestAnimationFrame(step_);
    }
  }

  markGrabbed() {
    this.g.firstChild.classList.add('grabbed');
  }

  unmarkGrabbed() {
    this.g.firstChild.classList.remove('grabbed');
  }

  /**
   * @private
   */
  addListeners_() {
    // put the event handlers on the g, but the event happens on the rect inside
    // http://www.open.ac.uk/blogs/brasherblog/?p=599
    // the ordinal and suit symbols use css pointer-event: none so the events pass through to their parent (the rect)
    this.g.addEventListener('pointerdown', this.downHandler);
    this.g.addEventListener('touchstart', dummyTouchStartHandler);
  }

  /**
   * @private
   */
  removeListeners_() {
    this.g.removeEventListener('pointerdown', this.downHandler);
    this.g.removeEventListener('touchstart', dummyTouchStartHandler);
  }

  /**
   * @private
   */
  addDragListeners_() {
    window.addEventListener('pointermove', this.moveHandler);
    window.addEventListener('pointerup', this.upHandler);
    window.addEventListener('pointercancel', this.cancelHandler);
  }

  /**
   * @private
   */
  removeDragListeners_() {
    window.removeEventListener('pointermove', this.moveHandler);
    window.removeEventListener('pointerup', this.upHandler);
    window.removeEventListener('pointercancel', this.cancelHandler);
  }

  /**
   * Takes the event coords from a DOM event and returns an SVG point
   * The PointerEvent contains several x,y coords; choice of client, offset, (page), (layer), screen, and (x, y)
   * @private
   * @param {PointerEvent} event
   * @returns {SVGPoint}
   */
  getPointerPoint_(event) {
    return Util.DOM2SVG(event.clientX, event.clientY);
  }

  /**
   * @param {PointerEvent} event 
   * @returns {boolean}
   */
  onpointerdown(event) {
    Util.absorbEvent(event);

    if ( event.pointerType === 'mouse' ) {
      if ( !(event.button === 0) ) {
        console.log('don\'t care about mouse button', event.button);
        return false;
      }
    }

    const place = asstab.getPlace(this);
    place.markDestination();
    ['n','ne','e','se','s','sw','w','nw'].forEach( dir => {
      let pl = place;
      if ( pl[dir] ) {
        pl = pl[dir];
        const card = asstab.getCard(pl);
        if ( card && card.value === this.value ) {
          pl.markDestination();
          // break;
        }
        // if ( card )
        //   break;
        pl.markDestination();
      }
    });

    this.ptOriginalPointerDown = this.getPointerPoint_(event);
    this.markGrabbed();
    this.ptOriginal = Util.newPoint(place.pt);
    this.ptOffset = Util.newPoint(
      this.ptOriginalPointerDown.x - place.pt.x,
      this.ptOriginalPointerDown.y - place.pt.y
    );
    baize.elevateCard(this);
    this.addDragListeners_();

    return false;
  }

  /**
   * Scale the SVGPoint (just created from a PointerEvent) into the viewBox
   * There's probably a smarter way of doing this using some obscure API
   * @private
   * @param {SVGPoint} pt
   */
  scalePointer_(pt) {
    const r = baize.ele.getBoundingClientRect();
    const w = r.right - r.left;
    const h = r.bottom - r.top;

    const xFactor = baize.width/w;
    const xMoved = pt.x - this.ptOriginalPointerDown.x;
    const xMovedScaled = Math.round(xMoved * xFactor);

    const yFactor = baize.height/h;
    const yMoved = pt.y - this.ptOriginalPointerDown.y;
    const yMovedScaled = Math.round(yMoved * yFactor);
    // console.log(xFactor, ':', this.ptOriginalPointerDown.x, pt.x, xMoved, xMovedScaled);
    // console.log(yFactor, ':', this.ptOriginalPointerDown.y, pt.y, yMoved, yMovedScaled);
    pt.x = this.ptOriginalPointerDown.x + xMovedScaled;
    pt.y = this.ptOriginalPointerDown.y + yMovedScaled;
  }

  /**
   * @param {PointerEvent} event 
   * @returns {boolean}
   */
  onpointermove(event) {
    Util.absorbEvent(event);

    const ptNew = this.getPointerPoint_(event);
    this.scalePointer_(ptNew);
    this.positionXY(ptNew.x - this.ptOffset.x, ptNew.y - this.ptOffset.y);

    return false;
  }

  /**
   * @param {PointerEvent} event 
   * @returns {boolean}
   */
  onpointerup(event) {
    Util.absorbEvent(event);

    const ptNew = this.getPointerPoint_(event);
    const ptNewCard = Util.newPoint(
      ptNew.x - this.ptOffset.x,
      ptNew.y - this.ptOffset.y
    );

    const plOld = asstab.getPlace(this);
    const oldCard = this;

    const plNew = grid.dropTarget(ptNewCard); // null if outside grid
    // console.log('new place at', plNew.x, plNew.y);

    if ( plNew ) {
      const newCard = asstab.getCard(plNew);

      if ( plOld === plNew ) {
        // we didn't move, fast position back to starting place
        this.position0()
      } else if ( plNew.isDestination() ) {
        if ( !newCard ) {
          // legal move to empty place, fast position to new place
          asstab.moveCard(plOld, plNew);
          this.position0();
        } else if ( oldCard.value === newCard.value ) {
          newCard.destroy();

          this.value *= 2;
          score.inc(this.value);
          this.updateText_();
          this.updateRect_();
          asstab.moveCard(plOld, plNew);
          this.position0();

          // grid.newCard(plOld);
          grid.newRandomCard();
        } else {
          // swap new and old
          // asstab.swapCards(plOld, plNew);
          // oldCard.position0();
          // newCard.position0();
          this.animate(ptNewCard);
        }
      } else {
        this.animate(ptNewCard);
      }
    } else {
      this.animate(ptNewCard);
    }

    this.unmarkGrabbed();
    grid.places.forEach( pl => {
      pl.unmarkDestination();
    });
    this.removeDragListeners_();

    // TODO get direction of swipe
    // game over if grid is full and we can't create a new card

    return false;
  }

  /**
   * @param {PointerEvent} event 
   */
  onpointercancel(event) {
    this.unmarkGrabbed();
    grid.places.forEach( pl => {
      pl.unmarkDestination();
    });
    this.removeDragListeners_();
  }
}

class Place {
  /**
   * @param {number} x 
   * @param {number} y 
   */
  constructor(x,y) {
    this.x = x
    this.y = y
    this.n = this.ne = this.e = this.se = this.s = this.sw = this.w = this.nw = null;

    let xPos = Constants.GRID_GAP + (x * (Constants.CARD_SIZE + Constants.CARD_GAP))
    let yPos = Constants.GRID_GAP + (y * (Constants.CARD_SIZE + Constants.CARD_GAP))
    this.pt = Util.newPoint(xPos, yPos)

    this.rect = document.createElementNS(Constants.SVG_NAMESPACE, 'rect');
    this.rect.classList.add('Place');
    Util.setAttributesNS(this.rect, {
      x: xPos.toString(),
      y: yPos.toString(),
      height: String(Constants.CARD_SIZE),
      width: String(Constants.CARD_SIZE),
      rx: String(Constants.CARD_RADIUS),
      ry: String(Constants.CARD_RADIUS)
    });
    document.getElementById('baize').appendChild(this.rect);
  }

  markDestination() {
    this.rect.classList.add('destination');
    // TODO if this place has a card, do something with that too
  }

  unmarkDestination() {
    this.rect.classList.remove('destination');
  }

  isDestination() {
    return this.rect.classList.contains('destination');
  }
}

class Grid {
  constructor() {
    /** @type {Place[]} */this.places = [];

    for ( let y=0; y<Constants.GRID_SIZE; y++ ) {
      for ( let x=0; x<Constants.GRID_SIZE; x++ ) {
        let c = new Place(x, y)
        this.places.push(c)
      }
    }
    this.places.forEach( c => {
      c.n = this.findPlace(c.x, c.y - 1);
      // c.ne = this.findPlace(c.x + 1, c.y - 1);
      c.e = this.findPlace(c.x + 1, c.y);
      // c.se = this.findPlace(c.x + 1, c.y + 1);
      c.s = this.findPlace(c.x, c.y + 1);
      // c.sw = this.findPlace(c.x - 1, c.y + 1);
      c.w = this.findPlace(c.x - 1, c.y);
      // c.nw = this.findPlace(c.x - 1, c.y - 1);
    });
  }

  /**
   * @param {Number} x 
   * @param {Number} y 
   * @return {Place}
   */
  findPlace(x,y) {
    return this.places.find(c => {return c.x == x && c.y == y});
  }

  /**
   * Find an accepting Place that this card overlaps the most
   * @param {!SVGPoint} ptNewCard
   * @returns {Place|null}
   */
  dropTarget(ptNewCard) {
    /**
     * @param {!SVGPoint} pt1 
     * @param {!SVGPoint} pt2 
     * @return {Number}
     */
    function overlapArea(pt1, pt2) {
      const rect1 = {left:pt1.x, top:pt1.y, right:pt1.x + Constants.CARD_SIZE, bottom:pt1.y + Constants.CARD_SIZE};
      const rect2 = {left:pt2.x, top:pt2.y, right:pt2.x + Constants.CARD_SIZE, bottom:pt2.y + Constants.CARD_SIZE};
      const xOverlap = Math.max(0, Math.min(rect1.right, rect2.right) - Math.max(rect1.left, rect2.left));
      const yOverlap = Math.max(0, Math.min(rect1.bottom, rect2.bottom) - Math.max(rect1.top, rect2.top));
      return xOverlap * yOverlap;
    }

    let plMost = null;
    let ovMost = 0;
    for ( const dst of this.places ) {
      let ov = overlapArea(dst.pt, ptNewCard);
      if ( ov > ovMost ) {
        ovMost = ov;
        plMost = dst;
      }
    }
    return plMost;
  }

  /**
   * @param {number=} row
   * @param {number=} col
   */
  randomEmptyPlace(row=undefined, col=undefined) {
    let emptyPlaces;
    if ( row !== undefined ) {
      emptyPlaces = this.places.filter( pl => pl.card === null && pl.y == row );
    } else if ( col !== undefined ) {
      emptyPlaces = this.places.filter( pl => pl.card === null && pl.x == col );
    } else {
      emptyPlaces = this.places.filter( pl => !asstab.getCard(pl) );
    }
    if ( !emptyPlaces.length ) {
      return null;
    }
    return emptyPlaces[Math.floor(Math.random()*emptyPlaces.length)];
  }

  /**
   * @param {Place} startPlace 
   */
  newCard(startPlace) {
    // TODO animate nextCard
    // create new nextCard
    const card = new Card(Math.random() > 0.5 ? 4 : 2);
    asstab.putCard(startPlace, card);
    baize.addCard(card);
    card.position0();
  }

  newRandomCard() {
    const place = this.randomEmptyPlace();
    if ( place ) {
      this.newCard(place);
    }
  }

  someCardsInTransit() {
    for ( const place of this.places ) {
      const card = asstab.getCard(place);
      if ( card && card.animationIds.length > 0 ) {
        // console.log(card.animationIds.length);
        return true;
      }
    }
    return false;
  }

  waitForCards() {
    return new Promise((resolve, reject) => {
      const tStart = performance.now();
      const tBored = tStart + 10000;
      const check = () => {
        if ( !this.someCardsInTransit() ) {
          resolve(performance.now() - tStart);
        } else if ( performance.now() > tBored ) {
          reject('timed out waiting for cards to finish moving');
        } else {
          window.setTimeout(check, 100);
        }
      }
      window.setTimeout(check, 100);
    });
  }

  *sweepNorth() {
    for ( let x=0; x<Constants.GRID_SIZE; x++ ) {
      for ( let y=1; y<Constants.GRID_SIZE; y++ ) {
        yield this.findPlace(x,y);
      }
    }
  }

  *sweepEast() {
    for ( let y=0; y<Constants.GRID_SIZE; y++ ) {
      for ( let x=Constants.GRID_SIZE-2; x>=0; x-- ) {
        yield this.findPlace(x,y);
      }
    }
  }

  *sweepSouth() {
    for ( let x=0; x<Constants.GRID_SIZE; x++ ) {
      for ( let y=Constants.GRID_SIZE-2; y>=0; y-- ) {
        yield this.findPlace(x,y);
      }
    }
  }

  *sweepWest() {
    for ( let y=0; y<Constants.GRID_SIZE; y++ ) {
      for ( let x=1; x<Constants.GRID_SIZE; x++ ) {
        yield this.findPlace(x,y);
      }
    }
  }

  /**
   * @param {function} sweepFn 
   * @param {string} dir 
   * @return {boolean}
   */
  mergeCards(sweepFn, dir) {
    let merged = false;
    for ( const oldPlace of sweepFn() ) {
      const oldCard = asstab.getCard(oldPlace);
      if ( !oldCard )
        continue;
      let newPlace = oldPlace[dir];
      if ( !newPlace )
        continue;
      let newCard = asstab.getCard(newPlace);
      if ( !newCard )
        continue;
      if ( oldCard.value !== newCard.value )
        continue;

      newCard.destroy();

      oldCard.value *= 2;
      oldCard.updateText_();
      oldCard.updateRect_();
      score.inc(oldCard.value);

      asstab.moveCard(oldPlace, newPlace);
      oldCard.animate(oldPlace.pt);

      merged = true;
    }
    return merged;
  }

  /**
   * @param {function} sweepFn 
   * @param {string} dir 
   * @return {boolean}
   */
  packCards(sweepFn, dir) {
    let packed = false;
    for ( const oldPlace of sweepFn() ) {
      const oldCard = asstab.getCard(oldPlace);
      if ( !oldCard )
        continue;
      let newPlace = oldPlace;
      while ( newPlace[dir] ) {
        if ( asstab.getCard(newPlace[dir]) )
          break;
        newPlace = newPlace[dir];
      }
      if ( oldPlace !== newPlace ) {
        asstab.moveCard(oldPlace, newPlace);
        oldCard.animate(oldPlace.pt);
        packed = true;
      }
    }
    return packed;
  }

  /**
   * @param {function} sweepFn 
   * @param {string} dir 
   */
  moveCards(sweepFn, dir) {
    let loops = 0;
    while ( this.packCards(sweepFn, dir) || this.mergeCards(sweepFn, dir) ) {
      loops++;
    }
    if ( loops > 0 ) {
      this.waitForCards()
      .then ( () => { 
        this.newRandomCard();
      });
    }
  }
}

document.documentElement.style.setProperty('--bg-color', 'Moccasin');
document.documentElement.style.setProperty('--hi-color', 'PeachPuff');
document.documentElement.style.setProperty('--ffont', 'Acme');

document.addEventListener('keydown', function(/** @type {KeyboardEvent} */kev) {
  // console.log(kev,kev.key,kev.keyCode,kev.ctrlKey);
  console.assert(kev.cancelable);
  if ( kev.key.startsWith('Arrow') ) {
    kev.preventDefault();
    switch ( kev.key ) {
      case 'ArrowUp': grid.moveCards(grid.sweepNorth.bind(grid), 'n'); break;
      case 'ArrowRight': grid.moveCards(grid.sweepEast.bind(grid), 'e'); break;
      case 'ArrowDown':  grid.moveCards(grid.sweepSouth.bind(grid), 's'); break;
      case 'ArrowLeft': grid.moveCards(grid.sweepWest.bind(grid), 'w'); break;
    }
  }
});

const baize = new Baize();
const score = new Score();
const grid = new Grid();
baize.setBox();

// grid.places.forEach( pl => {
//   grid.newCard(pl);
// });

grid.newRandomCard();
grid.newRandomCard();

// TODO timed loop to check if grid is full, game over, start new game
// TODO record high scores in localStorage
